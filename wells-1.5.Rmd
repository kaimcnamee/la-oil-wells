---
title: "wells-1.1"
author: "Kai McNamee"
date: '2022-04-19'
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(janitor)
library(tidycensus)
library(leaflet)
library(areal)
library(sf)
library(crosstalk)
library(h3jsr)
mile <- 1609.34
set.seed(90025)
```

# Read and generate data

## Read LA wells and ACS 2019 block group data

```{r read, eval=FALSE}
# LA County data (2019): https://data.lacounty.gov/en/dataset/Counts-and-Locations-of-Oil-Gas-Wells-in-LA-County/325t-kxpk

# LA City data (2020, but labels are unclear): https://geohub.lacity.org/datasets/lahub::oil-wells-inside-la-county/about

# read well data and convert lng-lat to sfc point data

la_wells <- read_csv("data/la_wells_county.csv") %>% 
  clean_names() %>% 
  filter(longitude != 0 & latitude != 0) %>% 
  mutate(coord_st = map2(.x = longitude, .y = latitude, ~st_point(c(.x, .y))),
         coord_sfc = st_sfc(coord_st, crs = 4326),
         well_status = tolower(well_status)) %>% 
  select(-coord_st, -the_geom)

st_geometry(la_wells) <- la_wells$coord_sfc

saveRDS(la_wells, "data/la_wells.RDS")
saveRDS(la_wells, "wells-map/la_wells.RDS")

# read acs 2019 data
acs_2019_vars <- load_variables(2019, "acs5") %>% filter(geography == "block group")

vars <- c(str_c("B02001_00", 1:8), "B03002_012")
names(vars) <- c("population", "white", "black", "native", "asian", "other_api",
                 "other", "two_or_more", "hispanic")

acs_2019 <- get_acs(year = 2019,
                    geography = "block group",
                    state = "06",
                    county = "037",
                    variables = vars,
                    geometry = T) %>%
  st_transform(4326) %>% 
  clean_names()

la_county_shape <- get_acs(year = 2019,
                           geography = "county",
                           state = "06",
                           county = "037",
                           variables = "B02001_001",
                           geometry = T) %>% 
  st_transform(4326) %>% 
  select(geometry) %>% 
  clean_names()

saveRDS(acs_2019, "data/acs_2019.RDS")
saveRDS(acs_2019, "wells-map/acs_2019.RDS")
acs_2019 <- readRDS("data/acs_2020.RDS")
saveRDS(la_county_shape, "wells-map/shapefiles/la_county.RDS")
```

## Generate buffers for different well statuses

```{r generate-buffers, eval=FALSE}
la_wells <- readRDS("data/la_wells.RDS")

# create buffer zones of varying sizes. use st_union to combine overlapping
# geometries -- this outputs 1 geometry feature for all of the shapes. use
# st_cast(..., "POLYGON) to separate the geometry features -- this outputs 1
# geometry feature per distinct boundary

get_buffers <- function(status, buffers){
  
  # define coordinates for wells in EPSG 6423 (meter-based CRS for CA)
  message("Filtering by well status: ", paste(status, collapse = ", "))
  poi <- st_transform(la_wells$coord_sfc[la_wells$well_status %in% status], 6423)
  
  df <- tibble()
  
  for (i in 1:length(buffers)) {
    
    # create buffer zone with input size
    message("Generating buffers with radius ", buffers[i])
    buffer <- st_buffer(poi, buffers[i])
    
    # union polygons
    union <- st_union(buffer)
    
    # split unioned polygons into distinct feature
    split <- st_cast(union, "POLYGON") 
    
    df <- df %>% rbind(tibble(buffer = buffers[i], geometry = split))
    
  }
  
  st_geometry(df) <- df$geometry
  df <- st_transform(df, 4326)
  return(df)
  
}

well_status <- unique(la_wells$well_status)
mile <- 1609.34
dput(seq(0.25, 1, 0.25) * mile)

buffers_all <- get_buffers(status = dput(well_status), 
                           buffers = dput(seq(0.25, 1, 0.25) * mile))

buffers_plugged <- get_buffers(status = "plugged", 
                               buffers = dput(seq(0.25, 1, 0.25) * mile))

buffers_active <- get_buffers(status = c("active", "new"),
                              buffers = dput(seq(0.25, 1, 0.25) * mile))

buffers_active_idle <- get_buffers(status = c("active", "new", "idle"),
                                   buffers = dput(seq(0.25, 1, 0.25) * mile))

### fix idle -- assigned "new" wells to "idle" buffers object

buffers_idle <- get_buffers(status = c("idle"),
                            buffers = dput(seq(0.25, 1, 0.25) * mile))

st_write(buffers_all, "shapefiles/buffers_all.shp")
st_write(buffers_plugged, "shapefiles/buffers_plugged.shp")
st_write(buffers_active, "shapefiles/buffers_active.shp")
st_write(buffers_active_idle, "shapefiles/buffers_active_idle.shp")
st_write(buffers_idle, "shapefiles/buffers_idle.shp")
```

## Interpolate data

```{r areal, eval=FALSE}
# read necessary data

la_wells <- readRDS("data/la_wells.RDS")
acs_2019 <- readRDS("data/acs_2019.RDS")

shapefile_names <- list.files("shapefiles") %>% str_sub(end = -5) %>% unique()

buffers_joined <- map_dfr(.x = shapefile_names, 
                          ~ tibble(status = .) %>% 
                            cbind(st_read(str_c("shapefiles/", ., ".shp"), quiet = T))) %>% 
  mutate(status = str_remove(status, "buffers_")) %>% 
  mutate(id = row_number()) 

st_geometry(buffers_joined) <- buffers_joined$geometry

# prep source data

acs_clean <- acs_2019 %>% 
  select(geoid, variable, estimate, geometry) %>% 
  pivot_wider(names_from = variable, values_from = estimate)

st_geometry(acs_clean) <- acs_clean$geometry
acs_clean <- st_transform(acs_clean, 6423)

# prep target geometries

buffers_target <- buffers_joined %>% st_transform(6423)

# areal interpolation

ar_extensive <- names(acs_clean) %>% 
  setdiff(c("geoid", "geometry"))

ar_validate(acs_clean, buffers_target, varList = ar_extensive,
            method = "aw", verbose = T)

# buffers_target

areal <- aw_interpolate(buffers_target, tid = id, 
                        source = acs_clean, sid = geoid,
                        weight = "sum", output = "sf",
                        extensive = ar_extensive)

saveRDS(areal, "data/buffers_ar.RDS")
```

```{r eval=FALSE}
buffers_ar <- readRDS("data/buffers_ar.RDS") %>% st_transform(4326) %>% 
  mutate(across(.cols = asian:white, round))

# count number of wells in each buffer polygon. st_contains returns T or F if
# points in a vector are contained in a specified polygon -- use map function to
# loop st_contains through all buffer polygons. 

check_wells <- map_dfr(.x = buffers_ar$geometry,
                           ~ {
                             st_contains(.x, la_wells$coord_sfc, sparse = F) %>%
                               apply(1, sum) %>%
                               as_tibble_col() %>%
                               unnest(value)
                           })

map_ar <- buffers_ar %>% 
  mutate(prop_non_white = round((100 - (white / population * 100)), 2),
         prop_white = round((white / population * 100), 2),
         prop_black = round((black / population * 100), 2),
         prop_native = round((native / population * 100), 2),
         prop_asian = round(((asian + other_api) / population * 100), 2),
         prop_hispanic = round((hispanic / population * 100), 2)) %>% 
  select(-(id:white)) %>%
  cbind(check_wells) %>% 
  rename("wells" = value) %>% 
  # pivot_longer(cols = prop_non_white:prop_hispanic, 
  #              names_to = "series", values_to = "values") %>% 
  drop_na()

saveRDS(map_ar, "wells-map/map_ar.RDS")
```

# Map

```{r leaflet-test, eval=FALSE}

# layer control will control which wells to show and which distance to show

map_active_idle <- buffers_ar %>% 
  filter(status == "active_idle") %>% 
  mutate(prop_non_white = round(100 - (white / population * 100), 2)) %>% 
  drop_na()

pal <- colorNumeric(palette = "Blues", domain = map_active_idle$prop_non_white, n = 100)
binpal <- colorBin(palette = "Blues", domain = 0:100, bins = 4)

leaflet() %>% 
  addProviderTiles(providers$CartoDB.Positron) %>% 
  
  addMapPane(name = "buffers", zIndex = 1) %>% 
  addMapPane(name = "wells", zIndex = 2) %>% 
  
  addPolygons(data = map_active_idle %>% 
                filter(buffer == 1 * mile),
              weight = 1,
              fillOpacity = 0.8,
              popup = ~str_c(prop_non_white, "% non white"),
              color = ~binpal(prop_non_white),
              
              group = "1 mile") %>% 
  
  addPolygons(data = map_active_idle %>% 
                filter(buffer == 0.5 * mile),
              weight = 1,
              fillOpacity = 0.8,
              popup = ~str_c(prop_non_white, "% non white"),
              color = ~binpal(prop_non_white),
              
              group = "1/2 mile") %>% 
  
  addPolygons(data = map_active_idle %>% 
                filter(buffer == 0.25 * mile),
              weight = 1,
              fillOpacity = 0.8,
              popup = ~str_c(prop_non_white, "% non white"),
              color = ~binpal(prop_non_white),
              
              group = "1/4 mile") %>% 
  
  addLayersControl(baseGroups = c("1 mile", "1/2 mile", "1/4 mile"),
                   position = "bottomright",
                   options = layersControlOptions(collapsed = FALSE)) %>% 
  
  addScaleBar(position = "bottomleft") %>% 
  
  addLegend(data = map_active_idle, 
            position = "bottomright",
            pal = binpal,
            values = ~prop_non_white,
            title = "Percentage",
            opacity = 1) 

```

```{r leaflet-shiny}
map_ar <- readRDS("wells-map/map_ar.RDS") %>% 
  pivot_longer(cols = prop_non_white:prop_hispanic,
               names_to = "series", values_to = "values") 

la_county <- readRDS("wells-map/shapefiles/la_county.RDS")
breaks <- seq(0, 100, 25)

pal <- colorNumeric(palette = "Blues", domain = 0:100)
pal <- colorBin(palette = "Blues", domain = 0:100, bins = breaks)

buffer_input <- 0.25 * mile
status_input <- "active_idle"

filtered_map <- map_ar %>% 
  filter(buffer == buffer_input & status == status_input & series == "prop_white")

leaflet() %>% 
  addProviderTiles(providers$CartoDB.Positron) %>%
  addPolygons(data = la_county, fillOpacity = 0) %>% 
  addPolygons(data = filtered_map,
              weight = 1,
              fillOpacity = 0.8,
              popup = ~str_c(values, "%"),
              fillColor = ~pal(values)) %>% 
  addLegend(data = filtered_map, 
            position = "bottomright",
            pal = pal,
            values = ~values,
            title = "Percentage",
            opacity = 1) 

```

# Models

```{r generate-sample, eval=FALSE}
la_wells <- readRDS("data/la_wells.RDS") %>% 
  mutate(id = row_number())
buffers_ar <- readRDS("data/buffers_ar.RDS")

# analysis by distance to block group centroids is going to take too long --
# draw a random sample from only those within 1/4 mile?

acs_2019 <- readRDS("data/acs_2019.RDS") %>% 
  select(geoid, variable, estimate, geometry) %>% 
  pivot_wider(names_from = variable, values_from = estimate) %>% 
  mutate(prop_non_white = round((100 - (white / population * 100)), 2),
         prop_white = round((white / population * 100), 2),
         prop_black = round((black / population * 100), 2),
         prop_native = round((native / population * 100), 2),
         prop_asian = round(((asian + other_api) / population * 100), 2),
         prop_hispanic = round((hispanic / population * 100), 2)) 

st_geometry(acs_2019) <- acs_2019$geometry %>% st_transform(6423)

# draw random sample from wells. check sample distribution is comparable to
# population distribution

wells_sample <- sample_n(la_wells %>% 
                           filter(!well_status %in% c("canceled", "unknown")),
                         2000)

well_sample_stats <- wells_sample %>% 
  st_drop_geometry() %>% 
  group_by(well_status) %>% 
  summarize(prop_sample = n()/2000 ) 

well_pop_stats <- la_wells %>% 
  st_drop_geometry() %>% 
  filter(!well_status %in% c("canceled", "unknown")) %>% 
  group_by(well_status) %>% 
  summarize(count = n(), .groups = "drop") %>% 
  mutate(prop_population = count / sum(count)) %>% 
  select(-count)

left_join(well_pop_stats, well_sample_stats, by = "well_status")

# generate 1/4 mile buffers around sampled wells, then filter acs block groups
# to those within buffers

sample_buffers <- wells_sample %>% 
  st_transform(6423) %>% 
  st_buffer(0.25 * mile) %>% 
  st_union() %>% 
  st_cast("POLYGON") %>% 
  as_tibble()

check_acs <- map_dfr(.x = acs_2019$geometry,
                           ~ {
                             st_intersects(.x, sample_buffers$geometry, sparse = F) %>%
                               apply(1, any) %>%
                               as_tibble_col() %>%
                               unnest(value)
                           })

acs_sample <- cbind(check_acs, acs_2019) %>% 
  filter(value == T) %>% 
  select(-value) 

st_geometry(acs_sample) <- acs_sample$geometry

saveRDS(wells_sample, "data/wells_sample.RDS")
st_write(sample_buffers, "shapefiles/sample_buffers.shp")
saveRDS(acs_sample, "data/acs_sample.RDS")
```

```{r}
wells_sample <- readRDS("data/wells_sample.RDS") %>% 
  st_transform(4326)
sample_buffers <- st_read("shapefiles/sample_buffers.shp")%>% 
  st_transform(4326)
acs_sample <- readRDS("data/acs_sample.RDS") %>%
  st_transform(4326)

leaflet() %>% 
  addProviderTiles(providers$CartoDB.Positron) %>%
  addPolygons(data = acs_sample,
              weight = 0.5,
              popup = ~geoid) %>% 
  addPolygons(data = sample_buffers$geometry, 
              fillOpacity = 0,
              color = "red",
              weight = 3)
```
```{r}
# test: subdivide blocks into h3 hexagons

# h <- acs_sample %>% filter(geoid == "060372674022")
# h_fill <- polyfill(h, res = 10, simple = FALSE)
# h_fill <- h3_to_polygon(unlist(h_fill$h3_polyfillers), simple = FALSE)

# generate hexagons to subdivide block groups and interpolate census data 

acs_fill <- polyfill(acs_sample, res = 10, simple = FALSE)
acs_fill_polygons <- h3_to_polygon(unlist(acs_fill$h3_polyfillers), simple = F)

leaflet() %>% 
  addProviderTiles(providers$CartoDB.Positron) %>% 
  # addPolygons(data = h,
  #             weight = 0.5,
  #             popup = ~geoid) %>% 
  addPolygons(data = acs_fill_polygons %>% slice(1:500))

# interpolate acs_sample data into h3 hexagons

ar_sample_target <- acs_fill_polygons %>% st_transform(6423)
ar_sample_source <- acs_sample %>% st_transform(6423)
ar_sample_ext <- names(acs_sample)[2:9] 

ar_validate(ar_sample_source, ar_sample_target, varList = ar_sample_ext,
            method = "aw", verbose = T)

# buffers_target

areal_sample <- aw_interpolate(ar_sample_target, tid = h3_address,
                               source = ar_sample_source, sid = geoid,
                               weight = "sum", output = "sf",
                               extensive = ar_sample_ext)

saveRDS(areal_sample, "data/areal_sample_h3.RDS")
```

```{r h3-distances, eval=FALSE}
# calculate distances with EPSG 6423

areal_sample <- readRDS("data/areal_sample_h3.RDS")
areal_sample_points <- h3_to_point(areal_sample$h3_address, simple = F) %>% st_transform(6423)

# define subsets of wells so that st_distance can retain well status

plugged_sample <- wells_sample$coord_sfc[wells_sample$well_status == "plugged"] %>% 
  st_as_sf() %>% st_transform(6423)

idle_sample <- wells_sample$coord_sfc[wells_sample$well_status == "idle"] %>% 
  st_as_sf() %>% st_transform(6423)

new_sample <- wells_sample$coord_sfc[wells_sample$well_status == "new"] %>% 
  st_as_sf() %>% st_transform(6423)

active_sample <- wells_sample$coord_sfc[wells_sample$well_status == "active"] %>% 
  st_as_sf() %>% st_transform(6423)

# calculate distance matrices

plugged_distance <- as_tibble(st_distance(areal_sample_points, plugged_sample$x)) %>%
  clean_names() %>%
  mutate(h3_address = areal_sample_points$h3_address, .before = v1)

idle_distance <- as_tibble(st_distance(areal_sample_points, idle_sample$x)) %>%
  clean_names() %>%
  mutate(h3_address = areal_sample_points$h3_address, .before = v1)

new_distance <- as_tibble(st_distance(areal_sample_points, new_sample$x)) %>%
  clean_names() %>%
  mutate(h3_address = areal_sample_points$h3_address, .before = v1)

ative_distance <- as_tibble(st_distance(areal_sample_points, active_sample$x)) %>%
  clean_names() %>%
  mutate(h3_address = areal_sample_points$h3_address, .before = v1)

# pivot distance matrices to extract minimum distance for each well type

plugged_min <- plugged_distance %>% 
  pivot_longer(2:ncol(.), names_to = "well", values_to = "distance") %>% 
  group_by(h3_address) %>% 
  filter(distance == min(distance))

idle_min <- idle_distance %>% 
  pivot_longer(2:ncol(.), names_to = "well", values_to = "distance") %>% 
  group_by(h3_address) %>% 
  filter(distance == min(distance))

new_min <- plugged_distance %>% 
  pivot_longer(2:ncol(.), names_to = "well", values_to = "distance") %>% 
  group_by(h3_address) %>% 
  filter(distance == min(distance))

active_min <- plugged_distance %>% 
  pivot_longer(2:ncol(.), names_to = "well", values_to = "distance") %>% 
  group_by(h3_address) %>% 
  filter(distance == min(distance))

# join distances with interpolated h3 data

areal_sample_joined <- areal_sample %>% 
  left_join(plugged_min %>% select(-well) %>% by = "h3_address") %>% 
  left_join(idle_min %>% select(-well), by = "h3_address") %>%
  left_join(new_min %>% select(-well), by = "h3_address") %>%
  left_join(active_min %>% select(-well), by = "h3_address") 

names(areal_sample_joined)[11:14] <- c("plugged", "idle", "new", "active")

saveRDS(areal_sample_joined, "data/areal_sample_joined.RDS")
```

```{r}
areal_sample_joined <- readRDS("data/areal_sample_joined.RDS")
```

